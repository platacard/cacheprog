# this is officially not recommended way of installing golangci-lint
# but it's choosen because it's easiest and most portable way to get it for testing purposes
install-go-binary github.com/golangci/golangci-lint/cmd/golangci-lint@v1.64.8 ./bin
exec ./bin/golangci-lint$exe --version
stdout 'v1\.64\.8(.*)h1:y5TdeVidMtBGG32zgSC7ZXTFNHrsJkDnpO4ItB3Am\+I='

# control run
env GOLANGCI_LINT_CACHE=$WORK/.golangci-lint-cache
exec ./bin/golangci-lint$exe run ./...
! stderr '(error|fail)'
rm ${GOLANGCI_LINT_CACHE}

# run with cache
mkdir -p $WORK/disk-cache
env CACHEPROG_ROOT_DIRECTORY=$WORK/disk-cache

# if short testing enable, use only disk-backed cache
[!short] env CACHEPROG_REMOTE_STORAGE_TYPE=s3 CACHEPROG_S3_PREFIX=tests/golangci-lint-v1-test
# cleanup path for consistency
[!short] env MC_FULLPATH=${MINIO_ALIAS}/${CACHEPROG_S3_BUCKET}/${CACHEPROG_S3_PREFIX}
[!short] mc rm --recursive --force ${MC_FULLPATH}

# run with cacheprog first time
set-cacheprog GOCACHEPROG
set-cacheprog GOLANGCI_LINT_CACHEPROG
exec ./bin/golangci-lint$exe run ./...
# we have no way to actually determine if cache entries has been used or not, so just rely on cacheprog log output
stderr 'Starting cacheprog'
! stderr '(error|fail)'

# ensure that minio bucket is not empty
[!short] mc du ${MC_FULLPATH}
[!short] stdout ${CACHEPROG_S3_BUCKET}/${CACHEPROG_S3_PREFIX}
[!short] ! stdout '^0B'
[!short] ! stdout '(^|\W)0 object'

# run with cacheprog second time, clean disk storage
rm ${CACHEPROG_ROOT_DIRECTORY}
exec ./bin/golangci-lint$exe run ./...
stderr 'Starting cacheprog'
! stderr '(error|fail)'

-- main.go --
package main

import "fmt"

func main() {
	fmt.Println("Hello world!")
}

-- go.mod --
module linttest

go 1.25

-- golangci-lint.yml --
linters:
  enable-all: true
  disable:
    - forbidigo
    - gofmt
    - goimports
    - gofumpt
